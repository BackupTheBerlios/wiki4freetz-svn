/* wikifile.c generated by valac 0.16.1, the Vala compiler
 * generated from wikifile.gs, do not modify */


#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <gio/gio.h>
#include <stdio.h>


#define TYPE_WIKI_FILE (wiki_file_get_type ())
#define WIKI_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_WIKI_FILE, WikiFile))
#define WIKI_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_WIKI_FILE, WikiFileClass))
#define IS_WIKI_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_WIKI_FILE))
#define IS_WIKI_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_WIKI_FILE))
#define WIKI_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_WIKI_FILE, WikiFileClass))

typedef struct _WikiFile WikiFile;
typedef struct _WikiFileClass WikiFileClass;
typedef struct _WikiFilePrivate WikiFilePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

struct _WikiFile {
	GObject parent_instance;
	WikiFilePrivate * priv;
};

struct _WikiFileClass {
	GObjectClass parent_class;
};

struct _WikiFilePrivate {
	const gchar* _page;
};

typedef enum  {
	IO_ERROR_FILE_NOT_FOUND,
	IO_ERROR_FILE_NO_READ_PERMISSION,
	IO_ERROR_FILE_IS_LOCKED
} IOError;
#define IO_ERROR io_error_quark ()

static gpointer wiki_file_parent_class = NULL;
extern gchar* home;

GType wiki_file_get_type (void) G_GNUC_CONST;
#define WIKI_FILE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_WIKI_FILE, WikiFilePrivate))
enum  {
	WIKI_FILE_DUMMY_PROPERTY,
	WIKI_FILE_PAGE
};
WikiFile* wiki_file_new (const gchar* pagename);
WikiFile* wiki_file_construct (GType object_type, const gchar* pagename);
void wiki_file_set_page (WikiFile* self, const gchar* value);
static inline GFile* wiki_file_get_file (WikiFile* self);
const gchar* wiki_file_get_page (WikiFile* self);
void wiki_file_store_text (WikiFile* self, const gchar* text);
gboolean wiki_file_exists (WikiFile* self);
GQuark io_error_quark (void);
gchar* wiki_file_as_html (WikiFile* self, GError** error);
static gchar* wiki_file_mk_heading (WikiFile* self, const gchar* line);
static void wiki_file_finalize (GObject* obj);
static void _vala_wiki_file_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec);
static void _vala_wiki_file_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec);


WikiFile* wiki_file_construct (GType object_type, const gchar* pagename) {
	WikiFile * self = NULL;
	const gchar* _tmp0_;
	g_return_val_if_fail (pagename != NULL, NULL);
	self = (WikiFile*) g_object_new (object_type, NULL);
	_tmp0_ = pagename;
	wiki_file_set_page (self, _tmp0_);
	return self;
}


WikiFile* wiki_file_new (const gchar* pagename) {
	return wiki_file_construct (TYPE_WIKI_FILE, pagename);
}


/**
 * Gets the associated file for the page
 */
static inline GFile* wiki_file_get_file (WikiFile* self) {
	GFile* result = NULL;
	const gchar* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_ = NULL;
	gchar* filepath;
	FILE* _tmp3_;
	GFile* _tmp4_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = home;
	_tmp1_ = self->priv->_page;
	_tmp2_ = g_strdup_printf ("%s/%s", _tmp0_, _tmp1_);
	filepath = _tmp2_;
	_tmp3_ = stdout;
	fprintf (_tmp3_, "Filepath: %s\n", filepath);
	_tmp4_ = g_file_new_for_path (filepath);
	result = _tmp4_;
	_g_free0 (filepath);
	return result;
}


/**
 * Stores wiki text to file
 */
static guint8* string_get_data (const gchar* self, int* result_length1) {
	guint8* result;
	guint8* res;
	gint res_length1;
	gint _res_size_;
	gint _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	guint8* _tmp3_;
	gint _tmp3__length1;
	guint8* _tmp4_;
	gint _tmp4__length1;
	g_return_val_if_fail (self != NULL, NULL);
	res = (guint8*) self;
	res_length1 = -1;
	_res_size_ = res_length1;
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	res_length1 = (gint) _tmp1_;
	_tmp2_ = res_length1;
	_tmp3_ = res;
	_tmp3__length1 = res_length1;
	_tmp4_ = _tmp3_;
	_tmp4__length1 = _tmp3__length1;
	if (result_length1) {
		*result_length1 = _tmp4__length1;
	}
	result = _tmp4_;
	return result;
}


static gchar* string_slice (const gchar* self, glong start, glong end) {
	gchar* result = NULL;
	gint _tmp0_;
	gint _tmp1_;
	glong string_length;
	glong _tmp2_;
	glong _tmp5_;
	gboolean _tmp8_ = FALSE;
	glong _tmp9_;
	gboolean _tmp12_;
	gboolean _tmp13_ = FALSE;
	glong _tmp14_;
	gboolean _tmp17_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	glong _tmp22_;
	gchar* _tmp23_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = strlen (self);
	_tmp1_ = _tmp0_;
	string_length = (glong) _tmp1_;
	_tmp2_ = start;
	if (_tmp2_ < ((glong) 0)) {
		glong _tmp3_;
		glong _tmp4_;
		_tmp3_ = string_length;
		_tmp4_ = start;
		start = _tmp3_ + _tmp4_;
	}
	_tmp5_ = end;
	if (_tmp5_ < ((glong) 0)) {
		glong _tmp6_;
		glong _tmp7_;
		_tmp6_ = string_length;
		_tmp7_ = end;
		end = _tmp6_ + _tmp7_;
	}
	_tmp9_ = start;
	if (_tmp9_ >= ((glong) 0)) {
		glong _tmp10_;
		glong _tmp11_;
		_tmp10_ = start;
		_tmp11_ = string_length;
		_tmp8_ = _tmp10_ <= _tmp11_;
	} else {
		_tmp8_ = FALSE;
	}
	_tmp12_ = _tmp8_;
	g_return_val_if_fail (_tmp12_, NULL);
	_tmp14_ = end;
	if (_tmp14_ >= ((glong) 0)) {
		glong _tmp15_;
		glong _tmp16_;
		_tmp15_ = end;
		_tmp16_ = string_length;
		_tmp13_ = _tmp15_ <= _tmp16_;
	} else {
		_tmp13_ = FALSE;
	}
	_tmp17_ = _tmp13_;
	g_return_val_if_fail (_tmp17_, NULL);
	_tmp18_ = start;
	_tmp19_ = end;
	g_return_val_if_fail (_tmp18_ <= _tmp19_, NULL);
	_tmp20_ = start;
	_tmp21_ = end;
	_tmp22_ = start;
	_tmp23_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) (_tmp21_ - _tmp22_));
	result = _tmp23_;
	return result;
}


void wiki_file_store_text (WikiFile* self, const gchar* text) {
	GFile* _tmp0_ = NULL;
	GFile* file;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (text != NULL);
	_tmp0_ = wiki_file_get_file (self);
	file = _tmp0_;
	{
		GFile* _tmp1_;
		gboolean _tmp2_ = FALSE;
		GFile* _tmp4_;
		GFileOutputStream* _tmp5_ = NULL;
		GFileOutputStream* _tmp6_;
		GFileOutputStream* _tmp7_;
		GDataOutputStream* _tmp8_;
		GDataOutputStream* _tmp9_;
		GDataOutputStream* dos;
		glong written;
		_tmp1_ = file;
		_tmp2_ = g_file_query_exists (_tmp1_, NULL);
		if (_tmp2_) {
			GFile* _tmp3_;
			_tmp3_ = file;
			g_file_delete (_tmp3_, NULL, &_inner_error_);
			if (_inner_error_ != NULL) {
				goto __catch5_g_error;
			}
		}
		_tmp4_ = file;
		_tmp5_ = g_file_create (_tmp4_, G_FILE_CREATE_REPLACE_DESTINATION, NULL, &_inner_error_);
		_tmp6_ = _tmp5_;
		if (_inner_error_ != NULL) {
			goto __catch5_g_error;
		}
		_tmp7_ = _tmp6_;
		_tmp8_ = g_data_output_stream_new ((GOutputStream*) _tmp7_);
		_tmp9_ = _tmp8_;
		_g_object_unref0 (_tmp7_);
		dos = _tmp9_;
		written = (glong) 0;
		while (TRUE) {
			glong _tmp10_;
			const gchar* _tmp11_;
			guint8* _tmp12_;
			gint _tmp12__length1;
			guint8* _tmp13_;
			gint _tmp13__length1;
			GDataOutputStream* _tmp14_;
			const gchar* _tmp15_;
			glong _tmp16_;
			const gchar* _tmp17_;
			guint8* _tmp18_;
			gint _tmp18__length1;
			guint8* _tmp19_;
			gint _tmp19__length1;
			gchar* _tmp20_ = NULL;
			gchar* _tmp21_;
			guint8* _tmp22_;
			gint _tmp22__length1;
			guint8* _tmp23_;
			gint _tmp23__length1;
			gssize _tmp24_ = 0L;
			gssize _tmp25_;
			gssize _tmp26_;
			glong _tmp27_;
			_tmp10_ = written;
			_tmp11_ = text;
			_tmp12_ = string_get_data (_tmp11_, &_tmp12__length1);
			_tmp13_ = _tmp12_;
			_tmp13__length1 = _tmp12__length1;
			if (!(_tmp10_ < ((glong) _tmp13__length1))) {
				break;
			}
			_tmp14_ = dos;
			_tmp15_ = text;
			_tmp16_ = written;
			_tmp17_ = text;
			_tmp18_ = string_get_data (_tmp17_, &_tmp18__length1);
			_tmp19_ = _tmp18_;
			_tmp19__length1 = _tmp18__length1;
			_tmp20_ = string_slice (_tmp15_, _tmp16_, (glong) _tmp19__length1);
			_tmp21_ = _tmp20_;
			_tmp22_ = string_get_data (_tmp21_, &_tmp22__length1);
			_tmp23_ = _tmp22_;
			_tmp23__length1 = _tmp22__length1;
			_tmp24_ = g_output_stream_write ((GOutputStream*) _tmp14_, _tmp23_, (gsize) _tmp23__length1, NULL, &_inner_error_);
			_tmp25_ = _tmp24_;
			_g_free0 (_tmp21_);
			_tmp26_ = _tmp25_;
			if (_inner_error_ != NULL) {
				_g_object_unref0 (dos);
				goto __catch5_g_error;
			}
			_tmp27_ = written;
			written = _tmp27_ + _tmp26_;
		}
		_g_object_unref0 (dos);
	}
	goto __finally5;
	__catch5_g_error:
	{
		GError* e = NULL;
		FILE* _tmp28_;
		GError* _tmp29_;
		const gchar* _tmp30_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp28_ = stderr;
		_tmp29_ = e;
		_tmp30_ = _tmp29_->message;
		fprintf (_tmp28_, "%s\n", _tmp30_);
		_g_error_free0 (e);
	}
	__finally5:
	if (_inner_error_ != NULL) {
		_g_object_unref0 (file);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	_g_object_unref0 (file);
}


/**
 * Check file existense
 */
inline gboolean wiki_file_exists (WikiFile* self) {
	gboolean result = FALSE;
	GFile* _tmp0_ = NULL;
	GFile* _tmp1_;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = wiki_file_get_file (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_file_query_exists (_tmp1_, NULL);
	_tmp3_ = _tmp2_;
	_g_object_unref0 (_tmp1_);
	result = _tmp3_;
	return result;
}


/**
 * Wiki syntax parser
 */
static gchar string_get (const gchar* self, glong index) {
	gchar result = '\0';
	glong _tmp0_;
	gchar _tmp1_;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = index;
	_tmp1_ = ((gchar*) self)[_tmp0_];
	result = _tmp1_;
	return result;
}


gchar* wiki_file_as_html (WikiFile* self, GError** error) {
	gchar* result = NULL;
	GFile* _tmp0_ = NULL;
	GFile* file;
	GString* _tmp1_;
	GString* sb;
	FILE* _tmp2_;
	const gchar* _tmp3_;
	GFile* _tmp4_;
	gboolean _tmp5_ = FALSE;
	gboolean inside_b;
	gboolean inside_i;
	gchar* insert = NULL;
	GString* _tmp68_;
	const gchar* _tmp69_;
	gchar* _tmp70_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = wiki_file_get_file (self);
	file = _tmp0_;
	_tmp1_ = g_string_new ("");
	sb = _tmp1_;
	_tmp2_ = stdout;
	_tmp3_ = self->priv->_page;
	fprintf (_tmp2_, "Get file as HTML: %s\n", _tmp3_);
	_tmp4_ = file;
	_tmp5_ = g_file_query_exists (_tmp4_, NULL);
	if (!_tmp5_) {
		result = NULL;
		_g_string_free0 (sb);
		_g_object_unref0 (file);
		return result;
	}
	inside_b = FALSE;
	inside_i = FALSE;
	{
		GFile* _tmp6_;
		GFileInputStream* _tmp7_ = NULL;
		GFileInputStream* _tmp8_;
		GFileInputStream* _tmp9_;
		GDataInputStream* _tmp10_;
		GDataInputStream* _tmp11_;
		GDataInputStream* dis;
		gchar* line = NULL;
		_tmp6_ = file;
		_tmp7_ = g_file_read (_tmp6_, NULL, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			goto __catch6_g_error;
		}
		_tmp9_ = _tmp8_;
		_tmp10_ = g_data_input_stream_new ((GInputStream*) _tmp9_);
		_tmp11_ = _tmp10_;
		_g_object_unref0 (_tmp9_);
		dis = _tmp11_;
		while (TRUE) {
			GDataInputStream* _tmp12_;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			const gchar* _tmp15_;
			const gchar* _tmp16_;
			gint i;
			const gchar* _tmp57_;
			gchar* _tmp58_ = NULL;
			const gchar* _tmp59_;
			gboolean _tmp60_ = FALSE;
			GString* _tmp63_;
			const gchar* _tmp64_;
			_tmp12_ = dis;
			_tmp13_ = g_data_input_stream_read_line (_tmp12_, NULL, NULL, &_inner_error_);
			_tmp14_ = _tmp13_;
			if (_inner_error_ != NULL) {
				_g_free0 (line);
				_g_object_unref0 (dis);
				goto __catch6_g_error;
			}
			_g_free0 (line);
			line = _tmp14_;
			_tmp15_ = line;
			if (!(_tmp15_ != NULL)) {
				break;
			}
			_tmp16_ = line;
			if (g_strcmp0 (_tmp16_, "") == 0) {
				GString* _tmp17_;
				_tmp17_ = sb;
				g_string_append (_tmp17_, "<p/>");
				continue;
			}
			i = -1;
			while (TRUE) {
				gint _tmp18_;
				const gchar* _tmp19_;
				gint _tmp20_;
				gint _tmp21_;
				gchar* _tmp22_;
				const gchar* _tmp23_;
				gint _tmp24_;
				gchar _tmp25_ = '\0';
				const gchar* _tmp35_;
				gint _tmp36_;
				gint _tmp37_;
				_tmp18_ = i;
				i = _tmp18_ + 1;
				_tmp19_ = line;
				_tmp20_ = strlen (_tmp19_);
				_tmp21_ = _tmp20_;
				if (!(_tmp18_ < _tmp21_)) {
					break;
				}
				_tmp22_ = g_strdup ("");
				_g_free0 (insert);
				insert = _tmp22_;
				_tmp23_ = line;
				_tmp24_ = i;
				_tmp25_ = string_get (_tmp23_, (glong) _tmp24_);
				switch (_tmp25_) {
					case '!':
					{
						{
							gint _tmp26_;
							_tmp26_ = i;
							i = _tmp26_ + 1;
						}
						break;
					}
					case '*':
					{
						{
							gboolean _tmp27_;
							gboolean _tmp30_;
							_tmp27_ = inside_b;
							if (_tmp27_) {
								gchar* _tmp28_;
								_tmp28_ = g_strdup ("<b>");
								_g_free0 (insert);
								insert = _tmp28_;
							} else {
								gchar* _tmp29_;
								_tmp29_ = g_strdup ("</b>");
								_g_free0 (insert);
								insert = _tmp29_;
							}
							_tmp30_ = inside_b;
							inside_b = !_tmp30_;
						}
						break;
					}
					case '/':
					{
						{
							gboolean _tmp31_;
							gboolean _tmp34_;
							_tmp31_ = inside_i;
							if (_tmp31_) {
								gchar* _tmp32_;
								_tmp32_ = g_strdup ("<i>");
								_g_free0 (insert);
								insert = _tmp32_;
							} else {
								gchar* _tmp33_;
								_tmp33_ = g_strdup ("</i>");
								_g_free0 (insert);
								insert = _tmp33_;
							}
							_tmp34_ = inside_b;
							inside_b = !_tmp34_;
						}
						break;
					}
					default:
					break;
				}
				_tmp35_ = insert;
				_tmp36_ = strlen (_tmp35_);
				_tmp37_ = _tmp36_;
				if (_tmp37_ > 0) {
					const gchar* _tmp38_;
					gint _tmp39_;
					gchar* _tmp40_ = NULL;
					gchar* _tmp41_;
					const gchar* _tmp42_;
					gchar* _tmp43_;
					gchar* _tmp44_;
					const gchar* _tmp45_;
					gint _tmp46_;
					const gchar* _tmp47_;
					gint _tmp48_;
					gint _tmp49_;
					gchar* _tmp50_ = NULL;
					gchar* _tmp51_;
					gchar* _tmp52_;
					gint _tmp53_;
					const gchar* _tmp54_;
					gint _tmp55_;
					gint _tmp56_;
					_tmp38_ = line;
					_tmp39_ = i;
					_tmp40_ = string_slice (_tmp38_, (glong) 0, (glong) _tmp39_);
					_tmp41_ = _tmp40_;
					_tmp42_ = insert;
					_tmp43_ = g_strconcat (_tmp41_, _tmp42_, NULL);
					_tmp44_ = _tmp43_;
					_tmp45_ = line;
					_tmp46_ = i;
					_tmp47_ = line;
					_tmp48_ = strlen (_tmp47_);
					_tmp49_ = _tmp48_;
					_tmp50_ = string_slice (_tmp45_, (glong) (_tmp46_ + 1), (glong) _tmp49_);
					_tmp51_ = _tmp50_;
					_tmp52_ = g_strconcat (_tmp44_, _tmp51_, NULL);
					_g_free0 (line);
					line = _tmp52_;
					_g_free0 (_tmp51_);
					_g_free0 (_tmp44_);
					_g_free0 (_tmp41_);
					_tmp53_ = i;
					_tmp54_ = insert;
					_tmp55_ = strlen (_tmp54_);
					_tmp56_ = _tmp55_;
					i = _tmp53_ + _tmp56_;
				}
			}
			_tmp57_ = line;
			_tmp58_ = wiki_file_mk_heading (self, _tmp57_);
			_g_free0 (line);
			line = _tmp58_;
			_tmp59_ = line;
			_tmp60_ = g_str_has_prefix (_tmp59_, " ");
			if (_tmp60_) {
				const gchar* _tmp61_;
				gchar* _tmp62_ = NULL;
				_tmp61_ = line;
				_tmp62_ = g_strdup_printf ("<pre>%s</pre>", _tmp61_);
				_g_free0 (line);
				line = _tmp62_;
			}
			_tmp63_ = sb;
			_tmp64_ = line;
			g_string_append (_tmp63_, _tmp64_);
		}
		_g_free0 (line);
		_g_object_unref0 (dis);
	}
	goto __finally6;
	__catch6_g_error:
	{
		GError* e = NULL;
		FILE* _tmp65_;
		GError* _tmp66_;
		const gchar* _tmp67_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp65_ = stderr;
		_tmp66_ = e;
		_tmp67_ = _tmp66_->message;
		fprintf (_tmp65_, "%s\n", _tmp67_);
		_g_error_free0 (e);
	}
	__finally6:
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == IO_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (insert);
			_g_string_free0 (sb);
			_g_object_unref0 (file);
			return NULL;
		} else {
			_g_free0 (insert);
			_g_string_free0 (sb);
			_g_object_unref0 (file);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp68_ = sb;
	_tmp69_ = _tmp68_->str;
	_tmp70_ = g_strdup (_tmp69_);
	result = _tmp70_;
	_g_free0 (insert);
	_g_string_free0 (sb);
	_g_object_unref0 (file);
	return result;
}


/**
 * Replacement for heading marker e.g. === : <h3>
 * 6 level will be supported
 */
static gchar* wiki_file_mk_heading (WikiFile* self, const gchar* line) {
	gchar* result = NULL;
	gint cnt;
	const gchar* _tmp15_;
	gchar* _tmp16_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (line != NULL, NULL);
	cnt = 0;
	while (TRUE) {
		const gchar* _tmp0_;
		gint _tmp1_;
		gchar _tmp2_ = '\0';
		gint _tmp3_;
		_tmp0_ = line;
		_tmp1_ = cnt;
		cnt = _tmp1_ + 1;
		_tmp2_ = string_get (_tmp0_, (glong) _tmp1_);
		if (!(_tmp2_ == '=')) {
			break;
		}
		_tmp3_ = cnt;
		if (_tmp3_ > 0) {
			gint _tmp4_;
			const gchar* _tmp5_;
			gint _tmp6_;
			const gchar* _tmp7_;
			gint _tmp8_;
			gint _tmp9_;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_;
			gint _tmp12_;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			_tmp4_ = cnt;
			_tmp5_ = line;
			_tmp6_ = cnt;
			_tmp7_ = line;
			_tmp8_ = strlen (_tmp7_);
			_tmp9_ = _tmp8_;
			_tmp10_ = string_slice (_tmp5_, (glong) _tmp6_, (glong) _tmp9_);
			_tmp11_ = _tmp10_;
			_tmp12_ = cnt;
			_tmp13_ = g_strdup_printf ("<h%i>%s</h%i>", _tmp4_, _tmp11_, _tmp12_);
			_tmp14_ = _tmp13_;
			_g_free0 (_tmp11_);
			result = _tmp14_;
			return result;
		}
	}
	_tmp15_ = line;
	_tmp16_ = g_strdup (_tmp15_);
	result = _tmp16_;
	return result;
}


const gchar* wiki_file_get_page (WikiFile* self) {
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_page;
	result = _tmp0_;
	return result;
}


void wiki_file_set_page (WikiFile* self, const gchar* value) {
	const gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	self->priv->_page = _tmp0_;
	g_object_notify ((GObject *) self, "page");
}


static void wiki_file_class_init (WikiFileClass * klass) {
	wiki_file_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (WikiFilePrivate));
	G_OBJECT_CLASS (klass)->get_property = _vala_wiki_file_get_property;
	G_OBJECT_CLASS (klass)->set_property = _vala_wiki_file_set_property;
	G_OBJECT_CLASS (klass)->finalize = wiki_file_finalize;
	g_object_class_install_property (G_OBJECT_CLASS (klass), WIKI_FILE_PAGE, g_param_spec_string ("page", "page", "page", NULL, G_PARAM_STATIC_NAME | G_PARAM_STATIC_NICK | G_PARAM_STATIC_BLURB | G_PARAM_READABLE | G_PARAM_WRITABLE));
}


static void wiki_file_instance_init (WikiFile * self) {
	self->priv = WIKI_FILE_GET_PRIVATE (self);
}


static void wiki_file_finalize (GObject* obj) {
	WikiFile * self;
	self = WIKI_FILE (obj);
	G_OBJECT_CLASS (wiki_file_parent_class)->finalize (obj);
}


/**
 * wikifile.gs - handles file operations
 */
GType wiki_file_get_type (void) {
	static volatile gsize wiki_file_type_id__volatile = 0;
	if (g_once_init_enter (&wiki_file_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (WikiFileClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) wiki_file_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (WikiFile), 0, (GInstanceInitFunc) wiki_file_instance_init, NULL };
		GType wiki_file_type_id;
		wiki_file_type_id = g_type_register_static (G_TYPE_OBJECT, "WikiFile", &g_define_type_info, 0);
		g_once_init_leave (&wiki_file_type_id__volatile, wiki_file_type_id);
	}
	return wiki_file_type_id__volatile;
}


static void _vala_wiki_file_get_property (GObject * object, guint property_id, GValue * value, GParamSpec * pspec) {
	WikiFile * self;
	self = WIKI_FILE (object);
	switch (property_id) {
		case WIKI_FILE_PAGE:
		g_value_set_string (value, wiki_file_get_page (self));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}


static void _vala_wiki_file_set_property (GObject * object, guint property_id, const GValue * value, GParamSpec * pspec) {
	WikiFile * self;
	self = WIKI_FILE (object);
	switch (property_id) {
		case WIKI_FILE_PAGE:
		wiki_file_set_page (self, g_value_get_string (value));
		break;
		default:
		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
		break;
	}
}



